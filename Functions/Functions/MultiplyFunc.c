// Описание функции умножения из видео

// Вспомогательные функции

int multiply_ints_as_polynomials(int x, int y) {
	int z = 0;                              // создаем новую переменную z
	while (x != 0) {                    // цикл пока х н станет равным нулю
		if ((x & 1) == 1) {             // конъюнкция х и 1 ( будет равным 1, только если бит х = 1)
			z ^= y;                     // исключающее или (равно 1 если только один из элементов равен 1) (xor)
		}
		y <<= 1;                        //смещаем y влево на 1 бит
		x >>= 1;                        // смещаем х вправо на 1 бит
	}
	return z;
}


// считаем количество бит 
int number_bits(int x) {
	int nb = 0;
	while (x != 0) {
		nb += 1;                 // увеличиваем счетчик на 1 
		x >>= 1;                 // сдвигаем х вправо на 1 бит, пока не станет раным нулю
	}
	return nb;
}

// x неотрицательное число
// m положительное число
int mod_int_as_polynomial(int x, int m) {
	int nbm = number_bits(m);              // считаем кол-во бит в m и в х
	while (1) {                            // продолжаем бесконено, пок не выйдем из функции
		int nbx = number_bits(x);
		if (nbx < nbm) {                    // если количество бит в х меньше чем в y, то возвращаем х
			return x;
		}
		int mshift = m << (nbx - nbm);     // иначе сдвигаем m влево на кол-во бит равную разнице бит
		x ^= mshift;                       // применяем исключающее или (xor) к х
	}
}

//Основная функция умножения:

// x, y  8 бит
// возвращаемое значение 8 бит
// аналогичная функция из сишного файла static uint8_t kuz_mul_gf256(uint8_t x, uint8_t y) разбитая на несколько функций
int kuznyechik_multiplication(int x, int y) {
	int z = multiply_ints_as_polynomials(x, y);     // умножаем x y как полиномы, получаем z 
	int m = 0b111000011;                            // представляем p(x) как полином p(x) = x^8 + x^7 + x^6 + x + 1
	return mod_int_as_polynomial(z, m);             // делим z на m
}